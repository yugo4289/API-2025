
##  API実習　2025　課題レポート（第2回）修正版

  
###  出題範囲：　API実習2025　第4回～第6回まで

###  提出期限：　2025/12/15(月) 17:00

## 出題範囲
- **API実習(4)**：レスポンスデータ設計、JSON/JSONP、フォーマット指定、セキュリティ（XSS, CSRF）、Same-Origin Policy、CORS
- **API実習(5)**：レスポンス項目命名規則、エラー設計、HTTPステータスコード、日付フォーマット、識別子設計
- **API実習(6)**：HTTP仕様、キャッシュ制御、メディアタイプ、コンテンツネゴシエーション、ステータスコード詳細


## 提出形式
- 各問に対して **400～600字程度の解答**を記述
- 図や表を用いる場合はMarkdown記法で挿入



## 課題一覧

### 問1：HTTPステータスコードの分類と役割
HTTPステータスコードは100番台から500番台まで分類されています。それぞれのカテゴリ（情報、成功、リダイレクト、クライアントエラー、サーバエラー）について、**代表的なコードと意味を3つずつ挙げ、API設計でどのような場面で使うか具体例を示してください**。

*情報*

100 Continue
これは暫定レスポンスで、その時点までのすべてに問題がなく、クライアントはリクエストを継続してよい、またもしリクエストが完了している場合はレスポンスを無視してよいことを示します。

101 Switching Protocols
このコードはクライアントからの Upgrade リクエストヘッダーのレスポンスとして送信され、サーバーはプロトコルを切り替えていることを示します。

102 Processing 非推奨;
このコードは WebDAV のコンテキストで使用され、サーバーはリクエストを受け取って処理しているが、まだレスポンスを提供できないことを示します。

*成功*
200 OK
リクエストが成功したことを示します。成功が意味することは、 HTTP メソッドにより異なります。
GET: リソースが読み込まれ、メッセージ本文で転送された。
HEAD: メッセージ本文がなく、表現ヘッダーがレスポンスに含まれている。
PUT または POST: 操作の結果を表すリソースがメッセージ本文で送信される。
TRACE: メッセージ本文に、サーバーが受け取ったリクエストメッセージが含まれている。

201 Created
リクエストは成功し、その結果新たなリソースが作成されたことを示します。これは一般的に、 POST リクエストや、一部の PUT リクエストを送信した後のレスポンスになります。

202 Accepted
リクエストは受理されたが、まだ実行されていないことを示します。 これはあいまいです。 HTTP ではリクエストを処理した結果を示す非同期なレスポンスを後から送信する方法がないためです。 リクエストは別のプロセスかサーバーが処理する、またはバッチ処理する予定です。

*リダイレクト*
300 Multiple Choices
エージェント駆動型コンテンツネゴシエーションにおいて、リクエストには複数のレスポンスがある可能性があり、ユーザーエージェントまたはユーザーはそれらの中から 1 つを選ぶ必要があります。クライアントがレスポンスを自動的に選択する標準的な方法はないため、これはほとんど使用されません。

301 Moved Permanently
リクエストされたリソースの URL が永遠に変更されたことを示します。レスポンスで新しい URL が与えられます。

302 Found
このレスポンスコードは、リクエストされたリソースの URI が 一時的に 変更されたことを示します。 URI は将来、さらに変更される可能性があります。従って、クライアントは将来のリクエストでも同じ URI を使用するべきです。

*クライアントエラー*
400 Bad Request
クライアントのエラーとみなされるもの（例えば、不正なリクエスト構文、不正なリクエストメッセージフレーム、不正なリクエストルーティング）のために、 サーバーがリクエストを処理できない、あるいは処理しようとしない場合を示します。

401 Unauthorized
HTTP 標準では "unauthorized" (不許可) と定義されていますが、意味的にはこのレスポンスは "unauthenticated" (未認証) です。 つまり、クライアントはリクエストされたレスポンスを得るためには認証を受けなければなりません。

404 Not Found
サーバーがリクエストされたリソースを発見できないことを示します。 ブラウザーでは、これは URL が解釈できなかったことを意味します。 API では、これは通信先が有効であるものの、リソース自体が存在しないことを意味することがあります。 サーバーは認証されていないクライアントからリソースの存在を隠すために、 403 Forbidden の代わりにこのレスポンスを返すことがあります。 このレスポンスコードはウェブで頻繁に見られるため、おそらくもっとも有名なコードでしょう。

*サーバエラー*
500 Internal Server Error
サーバー側で処理方法がわからない事態が発生したことを示します。 このエラーは汎用的なエラーで、サーバーが応答に適切な 5XX ステータスコードを見つけることができないことを示しています。

501 Not Implemented
リクエストメソッドをサーバーが対応しておらず、扱えないことを示します。サーバーが対応しなければならない (従って、このコードを返してはならない) メソッドは GET と HEAD だけです。

502 Bad Gateway
このエラーレスポンスは、リクエストの処理に必要なレスポンスを受け取るゲートウェイとして動作するサーバーが無効なレスポンスを受け取ったことを示します。

---

### 問2：JSONとXMLの比較
WebAPIのレスポンス形式としてJSONが主流になった理由を、**XMLとの比較で3つ以上挙げて説明してください**。また、**JSONPの仕組みと利用目的、セキュリティ上の問題点を簡潔にまとめてください**。

WebAPIのレスポンス形式としてJSONがXMLに代わり主流となった理由は、その構造的な優位性とWeb技術との高い親和性にあります。まず、XMLはデータ自体に加えて冗長な開始・終了タグを必要とするのに対し、JSONはキーと値のペアによるシンプルな構造を持つため、同じデータを表現する場合にファイルサイズが軽量になります。この軽量性は、ネットワークの転送量を削減し、モバイル環境などでのパフォーマンス向上に貢献します。また、冗長性が少ないため、クライアント側（特にブラウザ）でのデータ解析（パース）処理が高速になり、APIの応答性能が向上します。さらに、JSONはJavaScriptのオブジェクト記法を基にしているため、クライアント側のJavaScriptで特別なライブラリなしに、JSON.parse()によって直接オブジェクトとして容易に扱える点が決定的な強みであり、開発効率を大きく向上させました。これらの理由から、JSONはその高い可読性も相まって、WebAPIの標準形式としての地位を確立しました。
---

### 問3（実演）：PostmanでSheetDB APIにGETリクエスト
- 無償で利用できるSheetDBの公開エンドポイントを使い、Postmanで`GET`リクエストを送信してください。
- **操作手順**：
  1. Postmanを起動し、新規リクエストを作成
  2. メソッドを`GET`に設定
  3. URLに以下を入力：`https://sheetdb.io/api/v1/58f61be4dda40`
  4. Sendをクリック
- **報告内容**：
  - ステータスコード
    200ok
  - レスポンスヘッダ（`Content-Type`など）
    <img width="1727" height="579" alt="image" src="https://github.com/user-attachments/assets/85c5ff5c-c6e9-4d44-9030-48d4665112a9" />

  - レスポンスJSONのスクリーンショット
<img width="1372" height="496" alt="image" src="https://github.com/user-attachments/assets/5ecab4fa-1ebe-4610-97c2-0b9758482876" />
<img width="1226" height="369" alt="image" src="https://github.com/user-attachments/assets/44a8aa2a-ba95-45b2-b482-4ed401aaabe1" />

---

### 問4：キャッシュ制御の仕組み
HTTPキャッシュの2つのモデル（Expiration ModelとValidation Model）について、**仕組みと利用シーンを説明してください**。また、以下のヘッダの意味を答えてください。
```
Cache-Control: max-age=3600
Expires: Tue, 14 Dec 2021 00:00:00 JST
ETag: "abc123"
```
Expiration Modelは、サーバーがレスポンスとともにキャッシュの有効期限をクライアントに明示的に伝えるモデルです。クライアントはこの有効期限内であれば、オリジンサーバーに一切問い合わせることなくローカルに保存されたキャッシュを再利用するため、最も高速にリソースを取得できます。有効期限は主に Cache-Control ヘッダの max-age ディレクティブや Expires ヘッダによって設定され、リソースの更新頻度が低い静的ファイル（画像やCSSなど）のキャッシュに適しています。一方、Validation Modelは、キャッシュの有効期限が切れた後や、サーバー側で期限を長く設定できない動的コンテンツを扱う際に利用されます。このモデルでは、クライアントはキャッシュされたリソースがサーバー上で変更されているかどうかを検証するために、ETag や Last-Modified などの識別情報を含んだヘッダを付けてリクエストをサーバーに送ります。サーバー側でリソースが変更されていないと確認できた場合、レスポンスボディなしで 304 Not Modified ステータスコードを返します。これにより、リソース本体の再転送を回避できるため、通信は発生しても帯域幅の節約に大きく貢献します。

---

### 問5（実演）：レスポンスJSONの分析
- 問3で取得したレスポンスJSONを分析し、**キーの命名規則（キャメルケース、スネークケースなど）と構造の特徴をまとめてください**。
- **報告内容**：
  - 実際のレスポンス例
  　 <img width="1372" height="496" alt="image" src="https://github.com/user-attachments/assets/5ecab4fa-1ebe-4610-97c2-0b9758482876" />
　　<img width="1226" height="369" alt="image" src="https://github.com/user-attachments/assets/44a8aa2a-ba95-45b2-b482-4ed401aaabe1" />
  - 命名規則の評価
    
  - 改善提案

---

### 問6：エラー設計と詳細情報
APIでエラーが発生した場合、HTTPステータスコードだけでなく詳細情報を返すことが推奨されます。**以下の観点でエラー情報設計のポイントをまとめてください**。
- 開発者向けメッセージと利用者向けメッセージの違い
- エラー原因の分類（例：認証、権限、リソース不在）
- ドキュメントURLの付与の意義

---

### 問7：日付フォーマットと国際化
APIレスポンスで日付を扱う場合、RFC 3339（ISO8601）形式が推奨されます。**以下の3つのフォーマットの違いを説明し、どの形式を採用すべきか理由を述べてください**。
- `Sun, 05 Dec 2021 07:57:37 GMT`（RFC 1123）
- `2021-12-05T12:34:56+09:00`（RFC 3339）
- `Sun Dec 5 12:34:56 2021`（asctime形式）

---

### 問8（実演）：Acceptヘッダの実験
- Postmanで`Accept`ヘッダを`application/json`と`text/html`に変えてSheetDB APIにリクエストし、レスポンスの違いを確認してください。
- **報告内容**：
  - それぞれのレスポンスのスクリーンショット
  - 違いの説明

---

### 問9：セキュリティ対策（XSS・CSRF）
WebAPI利用時に発生しうるXSSとCSRF攻撃について、**攻撃の仕組みと被害例を説明し、それぞれの対策を3つずつ挙げてください**。また、**Same-Origin PolicyとCORSの関係を簡潔にまとめてください**。

---

### 問10：コンテンツネゴシエーション
HTTPのコンテンツネゴシエーションにおいて、**Acceptヘッダとq値（品質値）の役割を説明し、以下の例でサーバがどのメディアタイプを選択するか理由を述べてください**。
```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
```
