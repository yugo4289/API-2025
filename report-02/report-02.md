
##  API実習　2025　課題レポート（第2回）修正版

  
###  出題範囲：　API実習2025　第4回～第6回まで

###  提出期限：　2025/12/15(月) 17:00

## 出題範囲
- **API実習(4)**：レスポンスデータ設計、JSON/JSONP、フォーマット指定、セキュリティ（XSS, CSRF）、Same-Origin Policy、CORS
- **API実習(5)**：レスポンス項目命名規則、エラー設計、HTTPステータスコード、日付フォーマット、識別子設計
- **API実習(6)**：HTTP仕様、キャッシュ制御、メディアタイプ、コンテンツネゴシエーション、ステータスコード詳細


## 提出形式
- 各問に対して **400～600字程度の解答**を記述
- 図や表を用いる場合はMarkdown記法で挿入



## 課題一覧

### 問1：HTTPステータスコードの分類と役割
HTTPステータスコードは100番台から500番台まで分類されています。それぞれのカテゴリ（情報、成功、リダイレクト、クライアントエラー、サーバエラー）について、**代表的なコードと意味を3つずつ挙げ、API設計でどのような場面で使うか具体例を示してください**。

*情報*

100 Continue
これは暫定レスポンスで、その時点までのすべてに問題がなく、クライアントはリクエストを継続してよい、またもしリクエストが完了している場合はレスポンスを無視してよいことを示します。

101 Switching Protocols
このコードはクライアントからの Upgrade リクエストヘッダーのレスポンスとして送信され、サーバーはプロトコルを切り替えていることを示します。

102 Processing 非推奨;
このコードは WebDAV のコンテキストで使用され、サーバーはリクエストを受け取って処理しているが、まだレスポンスを提供できないことを示します。

*成功*
200 OK
リクエストが成功したことを示します。成功が意味することは、 HTTP メソッドにより異なります。
GET: リソースが読み込まれ、メッセージ本文で転送された。
HEAD: メッセージ本文がなく、表現ヘッダーがレスポンスに含まれている。
PUT または POST: 操作の結果を表すリソースがメッセージ本文で送信される。
TRACE: メッセージ本文に、サーバーが受け取ったリクエストメッセージが含まれている。

201 Created
リクエストは成功し、その結果新たなリソースが作成されたことを示します。これは一般的に、 POST リクエストや、一部の PUT リクエストを送信した後のレスポンスになります。

202 Accepted
リクエストは受理されたが、まだ実行されていないことを示します。 

*リダイレクト*
300 Multiple Choices
エージェント駆動型コンテンツネゴシエーションにおいて、リクエストには複数のレスポンスがある可能性があり、ユーザーエージェントまたはユーザーはそれらの中から 1 つを選ぶ必要があります。クライアントがレスポンスを自動的に選択する標準的な方法はないため、これはほとんど使用されません。

301 Moved Permanently
リクエストされたリソースの URL が永遠に変更されたことを示します。レスポンスで新しい URL が与えられます。

302 Found
このレスポンスコードは、リクエストされたリソースの URI が 一時的に 変更されたことを示します。 URI は将来、さらに変更される可能性があります。従って、クライアントは将来のリクエストでも同じ URI を使用するべきです。

*クライアントエラー*
400 Bad Request
クライアントのエラーとみなされるもののために、 サーバーがリクエストを処理できない、あるいは処理しようとしない場合を示します。

401 Unauthorized
HTTP 標準では "unauthorized" (不許可) と定義されていますが、意味的にはこのレスポンスは "unauthenticated" (未認証) です。 つまり、クライアントはリクエストされたレスポンスを得るためには認証を受けなければなりません。

404 Not Found
サーバーがリクエストされたリソースを発見できないことを示します。

*サーバエラー*
500 Internal Server Error
サーバー側で処理方法がわからない事態が発生したことを示します。

501 Not Implemented
リクエストメソッドをサーバーが対応しておらず、扱えないことを示します。

502 Bad Gateway
このエラーレスポンスは、リクエストの処理に必要なレスポンスを受け取るゲートウェイとして動作するサーバーが無効なレスポンスを受け取ったことを示します。

---

### 問2：JSONとXMLの比較
WebAPIのレスポンス形式としてJSONが主流になった理由を、**XMLとの比較で3つ以上挙げて説明してください**。また、**JSONPの仕組みと利用目的、セキュリティ上の問題点を簡潔にまとめてください**。

WebAPIのレスポンス形式としてJSONがXMLに代わり主流となった理由は、その構造的な優位性とWeb技術との高い親和性にあります。まず、XMLはデータ自体に加えて冗長な開始・終了タグを必要とするのに対し、JSONはキーと値のペアによるシンプルな構造を持つため、同じデータを表現する場合にファイルサイズが軽量になります。この軽量性は、ネットワークの転送量を削減し、モバイル環境などでのパフォーマンス向上に貢献します。また、冗長性が少ないため、クライアント側（特にブラウザ）でのデータ解析（パース）処理が高速になり、APIの応答性能が向上します。さらに、JSONはJavaScriptのオブジェクト記法を基にしているため、クライアント側のJavaScriptで特別なライブラリなしに、JSON.parse()によって直接オブジェクトとして容易に扱える点が決定的な強みであり、開発効率を大きく向上させました。これらの理由から、JSONはその高い可読性も相まって、WebAPIの標準形式としての地位を確立しました。

---

### 問3（実演）：PostmanでSheetDB APIにGETリクエスト
- 無償で利用できるSheetDBの公開エンドポイントを使い、Postmanで`GET`リクエストを送信してください。
- **操作手順**：
  1. Postmanを起動し、新規リクエストを作成
  2. メソッドを`GET`に設定
  3. URLに以下を入力：`https://sheetdb.io/api/v1/58f61be4dda40`
  4. Sendをクリック
- **報告内容**：
  - ステータスコード
    200ok
  - レスポンスヘッダ（`Content-Type`など）
    <img width="1727" height="579" alt="image" src="https://github.com/user-attachments/assets/85c5ff5c-c6e9-4d44-9030-48d4665112a9" />

  - レスポンスJSONのスクリーンショット
<img width="1372" height="496" alt="image" src="https://github.com/user-attachments/assets/5ecab4fa-1ebe-4610-97c2-0b9758482876" />
<img width="1226" height="369" alt="image" src="https://github.com/user-attachments/assets/44a8aa2a-ba95-45b2-b482-4ed401aaabe1" />

---

### 問4：キャッシュ制御の仕組み
HTTPキャッシュの2つのモデル（Expiration ModelとValidation Model）について、**仕組みと利用シーンを説明してください**。また、以下のヘッダの意味を答えてください。
```
Cache-Control: max-age=3600
Expires: Tue, 14 Dec 2021 00:00:00 JST
ETag: "abc123"
```
Expiration Modelは、サーバーがレスポンスとともにキャッシュの有効期限をクライアントに明示的に伝えるモデルです。クライアントはこの有効期限内であれば、オリジンサーバーに一切問い合わせることなくローカルに保存されたキャッシュを再利用するため、最も高速にリソースを取得できます。有効期限は主に Cache-Control ヘッダの max-age ディレクティブや Expires ヘッダによって設定され、リソースの更新頻度が低い静的ファイル（画像やCSSなど）のキャッシュに適しています。一方、Validation Modelは、キャッシュの有効期限が切れた後や、サーバー側で期限を長く設定できない動的コンテンツを扱う際に利用されます。このモデルでは、クライアントはキャッシュされたリソースがサーバー上で変更されているかどうかを検証するために、ETag や Last-Modified などの識別情報を含んだヘッダを付けてリクエストをサーバーに送ります。サーバー側でリソースが変更されていないと確認できた場合、レスポンスボディなしで 304 Not Modified ステータスコードを返します。これにより、リソース本体の再転送を回避できるため、通信は発生しても帯域幅の節約に大きく貢献します。

---

### 問5（実演）：レスポンスJSONの分析
- 問3で取得したレスポンスJSONを分析し、**キーの命名規則（キャメルケース、スネークケースなど）と構造の特徴をまとめてください**。
- **報告内容**：
  - 実際のレスポンス例
  　 <img width="1372" height="496" alt="image" src="https://github.com/user-attachments/assets/5ecab4fa-1ebe-4610-97c2-0b9758482876" />
　　<img width="1226" height="369" alt="image" src="https://github.com/user-attachments/assets/44a8aa2a-ba95-45b2-b482-4ed401aaabe1" />
  - 命名規則の評価
    　・キーが複合語になった際に単語の区切りが不明確になり、可読性が低下する可能性がある
  - 改善提案
・ルート要素をオブジェクトにし、"data" フィールド内に配列を格納することで、ページネーションやメタ情報を追加しやすくする。
・idやageなどの数値が文字列として返されないようにする
---

### 問6：エラー設計と詳細情報
APIでエラーが発生した場合、HTTPステータスコードだけでなく詳細情報を返すことが推奨されます。**以下の観点でエラー情報設計のポイントをまとめてください**。
- 開発者向けメッセージと利用者向けメッセージの違い
  ・開発者向けメッセージでは、APIを呼び出している開発者が、エラーの根本原因を特定し、デバッグするために必要な技術情報を提供することが目的なので、具体的なエラーコード、どのフィールドでバリデーションエラーが発生したか、リクエストされた不正な値、発生したタイムスタンプなど、詳細かつ技術的な情報を含める必要がある。
  ・利用者向けメッセージでは、APIの最終的な利用者のインターフェースに表示するための、分かりやすく、行動を促すメッセージを提供することが目的なので、技術的な専門用語を避け、ユーザーが理解できる自然な言葉で記述する。
- エラー原因の分類（例：認証、権限、リソース不在）
・エラー発生時は、HTTPステータスコード（4xx, 5xx）を適切に使い分け、詳細情報内でそのエラーのカテゴリを明確にする
- ドキュメントURLの付与の意義
・エラーレスポンスに、エラーに関する詳細を記述したドキュメントへのURLを含めることは、APIのユーザビリティを高めることに有効
---

### 問7：日付フォーマットと国際化
APIレスポンスで日付を扱う場合、RFC 3339（ISO8601）形式が推奨されます。**以下の3つのフォーマットの違いを説明し、どの形式を採用すべきか理由を述べてください**。
- `Sun, 05 Dec 2021 07:57:37 GMT`（RFC 1123）
  ・HTTPヘッダで標準的に使用される形式です。タイムゾーンは通常グリニッジ標準時または協定世界時で固定されます。曜日名を含むため、人間には読みやすいが、データ形式としては冗長
  
- `2021-12-05T12:34:56+09:00`（RFC 3339）
  ・ISO 8601 規格に基づいていて、APIレスポンスのデファクトスタンダードです。日付と時刻がハイフンやコロンで区切られ、末尾にタイムゾーン情報が含まれます
  
- `Sun Dec 5 12:34:56 2021`（asctime形式）
  ・主にUNIX系OSやC言語の標準ライブラリなどで使われる形式です。タイムゾーン情報が欠落している、またはOSの設定に依存して曖昧であるため、異なるシステム間での時刻のやり取りには不向きです
---

### 問8（実演）：Acceptヘッダの実験
- Postmanで`Accept`ヘッダを`application/json`と`text/html`に変えてSheetDB APIにリクエストし、レスポンスの違いを確認してください。
- **報告内容**：
  - それぞれのレスポンスのスクリーンショット
  - application/json
<img width="1709" height="771" alt="image" src="https://github.com/user-attachments/assets/aedad358-ae23-434e-b8fe-90da8beca62c" />

　- text/html
<img width="1704" height="769" alt="image" src="https://github.com/user-attachments/assets/272e9729-e7ad-42cd-8922-c4c296cec6ff" />

  - 違いの説明
Server-timingが追加された
---

### 問9：セキュリティ対策（XSS・CSRF）
WebAPI利用時に発生しうるXSSとCSRF攻撃について、**攻撃の仕組みと被害例を説明し、それぞれの対策を3つずつ挙げてください**。また、**Same-Origin PolicyとCORSの関係を簡潔にまとめてください**。
1. XSS
XSSは、攻撃者が悪意のあるスクリプトをWebサイトに注入し、そのサイトを訪れた他のユーザーのブラウザで実行させる攻撃です。

仕組みと被害例: サーバーがユーザーからの入力値を適切にエスケープせずにHTMLとして出力することで発生します。これにより、ユーザーのセッションクッキーが盗まれたり、機密情報が窃取されたりする被害が生じます

主な対策
出力時のエスケープ処理: HTMLの特殊文字（<, > など）をエンティティ参照に変換し、スクリプトを単なるテキストとして扱わせます。

入力値のサニタイズ（無害化）: 許容するタグや属性のみを残し、それ以外の悪意のあるスクリプトをサーバー側で除去します。

Content Security Policy (CSP) の適用: 実行を許可するスクリプトの取得元をHTTPヘッダでブラウザに指示し、外部からの不正なスクリプト実行を制限します。

API利用におけるセキュリティ対策（XSS・CSRF）とオリジン制御 🛡️
WebAPIの利用において、**XSS（クロスサイトスクリプティング）とCSRF（クロスサイトリクエストフォージェリ）**は、ユーザーの安全を脅かす代表的な脆弱性です。

1. XSS（Cross-Site Scripting）
XSSは、攻撃者が悪意のあるスクリプトをWebサイトに注入し、そのサイトを訪れた他のユーザーのブラウザで実行させる攻撃です。

仕組みと被害例: サーバーがユーザーからの入力値を適切にエスケープせずにHTMLとして出力することで発生します。これにより、ユーザーのセッションクッキーが盗まれたり、機密情報が窃取されたりする被害が生じます .

主な対策（3つ）
出力時のエスケープ処理: HTMLの特殊文字（<, > など）をエンティティ参照に変換し、スクリプトを単なるテキストとして扱わせます。

入力値のサニタイズ（無害化）: 許容するタグや属性のみを残し、それ以外の悪意のあるスクリプトをサーバー側で除去します。

Content Security Policy (CSP) の適用: 実行を許可するスクリプトの取得元をHTTPヘッダでブラウザに指示し、外部からの不正なスクリプト実行を制限します。

2. CSRF
CSRFは、攻撃者が用意した不正なWebサイトから、ユーザーが認証済みのターゲットサイトに意図しないリクエストを強制的に送信させる攻撃です。

仕組みと被害例: ユーザーがターゲットサイトにログインし、セッションクッキーが有効な状態であることを利用し、ユーザーの権限でパスワード変更や金銭の送金といったあらゆる操作を勝手に行わせます .

主な対策
CSRFトークンの導入: サーバーが発行した推測不可能なワンタイムトークンをリクエストに含め、サーバー側で検証します。

SameSite Cookie 属性の利用: クッキーに SameSite 属性を設定し、クロスサイトからのリクエストにセッションクッキーが添付されることを防ぎます。

Refererヘッダの検証: リクエスト元のオリジンがターゲットサイトと一致するかをサーバー側で確認します。

---

### 問10：コンテンツネゴシエーション
HTTPのコンテンツネゴシエーションにおいて、**Acceptヘッダとq値（品質値）の役割を説明し、以下の例でサーバがどのメディアタイプを選択するか理由を述べてください**。
```
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
```
HTTPのコンテンツネゴシエーションは、クライアントとサーバーが、利用可能なリソースの複数の表現の中から、クライアントにとって最適なものを自動的に選択する仕組みです。
・Accept ヘッダは、クライアントが、リクエストに対するレスポンスとして受け入れ可能なメディアタイプ（MIMEタイプ)のリストをサーバーに伝えるために使用されます。サーバーはこのリストを参照し、自身が提供できる形式の中から最適なものを選択してレスポンスを返します。

・q 値（Quality Value、品質値）は、Accept ヘッダ内で、クライアントが指定した各メディアタイプに対する相対的な優先度を示すために使用されるパラメータです

HTTPのコンテンツネゴシエーションにおいて、サーバーがどのメディアタイプを選択するかは、クライアントが Accept ヘッダを通じて伝えるq値によって決定されます。このq値は、クライアントが受け入れ可能な各メディアタイプに対する相対的な優先度を示しており、値が大きいほど優先度が高くなります。提示されたヘッダは、text/html、application/xhtml+xml、および image/webp がq値の省略により最大の1.0の優先度を持つことが分かります。一方で、application/xml はq=0.9、/はq=0.8となり、優先度が低くなります。したがって、サーバーは、自身が提供可能な形式の中で、最も高いq=1.0のグループからメディアタイプを選択します。一般的に、Webコンテンツを扱うサーバーであれば、このグループ内で最も優先度の高いtext/htmlまたはapplication/xhtml+xmlを選択し、クライアントにその形式でレスポンスを返すことになります。
